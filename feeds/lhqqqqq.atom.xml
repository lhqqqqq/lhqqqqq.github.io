<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>lhqqqqq's BLOG</title><link href="http://lhqqqqq.github.io/" rel="alternate"></link><link href="http://lhqqqqq.github.io/feeds%5Clhqqqqq.atom.xml" rel="self"></link><id>http://lhqqqqq.github.io/</id><updated>2015-04-30T20:36:39+08:00</updated><entry><title>动态内存与智能指针</title><link href="http://lhqqqqq.github.io/cpp/shared_ptr.html" rel="alternate"></link><updated>2015-04-30T20:36:39+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-30:cpp/shared_ptr.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;from 《C++ Primer》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=""&gt;一、动态内存&lt;/h1&gt;
&lt;p&gt;程序使用的&lt;strong&gt;内存&lt;/strong&gt;包括：静态内存、栈内存动态内存；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态内存&lt;/strong&gt;用来保存局部static对象、类static数据成员和定义在任何函数之外的变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈内存&lt;/strong&gt;用来保存定义在函数内的非static对象。&lt;/p&gt;
&lt;p&gt;分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态内存&lt;/strong&gt;被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，即不再使用时，代码必须显示地销毁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;STL容器均是使用动态内存！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C++中，使用&lt;strong&gt;new&lt;/strong&gt;和&lt;strong&gt;delete&lt;/strong&gt;这对&lt;strong&gt;运算符&lt;/strong&gt;来管理动态内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;new和delete是运算符，malloc和free是库函数。&lt;a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/16/2593754.html"&gt;它们的不同？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;new&lt;/strong&gt;：在动态内存中为对象分配空间并返回一个指向该对象的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;delete&lt;/strong&gt;：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;h1 id="newdelete"&gt;二、new和delete&lt;/h1&gt;
&lt;p&gt;在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int *pi = new int；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，动态分配的对象是默认初始化的，即内置类型或组合类型的对象的值是未定义的，类类型的对象将采用默认初始化函数进行初始化。&lt;/p&gt;
&lt;p&gt;可以使用直接初始化：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int *pi = new int(1124);
stirng *ps = new string(10, '9');
vector&amp;lt;int&amp;gt; *pv = new vector&amp;lt;int&amp;gt;{0,1,2,3,4}; //新标准的列表初始化
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于内置类型，若未直接初始化，也应当值初始化：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int *pi1 = new int;     //默认初始化，*pi1的值未定义
int *pi2 = new int();   //值初始化为0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;delete表达式接受一个指针，指向要释放的对象，将动态内存归还给系统。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;delete p;   //p为指向一个动态分配的对象或一个空指针
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当delete一个指针后，虽然指针值无效，但其上仍保存着已经释放了的动态内存的地址，称为空悬指针（dangling pointer），即指向一块曾经保存数据对象但现在已经无效的内存的指针。可以在delete之后，将nullptr赋予指针，支出指针不指向任何对象。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;delete p;
p = nullptr;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;nullptr为C++11标准引入的特殊类型的字面值，表示空指针，代替预处理常量NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="_1"&gt;三、智能指针&lt;/h1&gt;
&lt;p&gt;不正确释放动态内存，会引发问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忘记释放内存，会产生&lt;strong&gt;内存泄露&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;在尚有指针引用内存的情况下释放，会产生&lt;strong&gt;引用非法内存&lt;/strong&gt;的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更容易且更安全地使用动态内存，C++11标准引入（boost库中已有）两种&lt;strong&gt;智能指针（smart pointer）&lt;/strong&gt;类型来管理动态对象。智能指针与常规指针的区别是它在负责自动释放所指向的对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;shared_ptr&lt;/strong&gt;允许多个指针指向同一对象；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique_str&lt;/strong&gt;独占所指向的对象；&lt;/li&gt;
&lt;li&gt;还有一种名为&lt;strong&gt;weak_ptr&lt;/strong&gt;的伴随类，它是一种&lt;a href="reference.html"&gt;弱引用&lt;/a&gt;，指向shared_ptr所管理的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述三种类型都定义在memory头文件中。&lt;/p&gt;
&lt;p&gt;创建：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;shared_ptr&amp;lt;string&amp;gt; p1;      //可以指向string的shared_ptr
shared_ptr&amp;lt;lit&amp;lt;int&amp;gt;&amp;gt; p1;    //可以指向int的list的shared_ptr
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;智能指针的使用（如判断、指向、解引用）与普通指针相同。&lt;/p&gt;
&lt;p&gt;智能指针的操作：&lt;/p&gt;
&lt;p&gt;shared_ptr和unique_ptr均支持的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shared_ptr&lt;t&gt; sp/unique_ptr&lt;t&gt; up &lt;/t&gt;&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;空智能指针，可以指向T类型的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p &lt;/p&gt;
&lt;p&gt;将p作为条件判断，空则为false，指向一个对象则为true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;*p        &lt;/p&gt;
&lt;p&gt;解引用p&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.get()   &lt;/p&gt;
&lt;p&gt;返回p中保存的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;swap(p,q)/p.swap(q)   &lt;/p&gt;
&lt;p&gt;交换p和q中的指针&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有shared_ptr支持的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;make_shared&lt;t&gt;(args)&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;返回一个shared_ptr，指向一个动态分配的T类型对象，使用args初始化此对象（最安全的分配和使用动态内存的方法！）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.use_count()         &lt;/p&gt;
&lt;p&gt;返回p共享对象的智能指针量（可能很慢！用于调试！）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.unique()            &lt;/p&gt;
&lt;p&gt;若p.use_count()为1，返回true；否则返回false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;share_ptr&lt;t&gt; p(q) &lt;/t&gt;&lt;/p&gt;
&lt;p&gt;p是q的拷贝；会递增q中的计数器。（q中的指针必须能转换成*T!)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p = q     &lt;/p&gt;
&lt;p&gt;此操作会递减p的引用计数，递增q中的引用计数；若p的引用计数变为0，则将其管理的原内存释放（p和q都是shared_ptr，且保存的指针必须能相互转换！）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体示例：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//指向一个值为9的int的shared_ptr
share_ptr&amp;lt;int&amp;gt; p1 = make_shared&amp;lt;int&amp;gt;(9);
//指向一个值为"hello"的string的shared_ptr
share_ptr&amp;lt;string&amp;gt; p2 = make_shared&amp;lt;string&amp;gt;("hello");
//指向一个值初始化的(对于int为0)int的shared_ptr
share_ptr&amp;lt;int&amp;gt; p3 = make_shared&amp;lt;int&amp;gt;();
//可以使用auto，这里指向空的string组成的vector
auto p4 = make_shared&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;auto q(p1);     //q和p1均指向相同的int对象9，此对象有两个引用者。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个shared_ptr都有一个关联计数器，称为&lt;strong&gt;引用计数（reference count）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用计数递增：拷贝（如拷贝初始化、作为参数传递给函数、作为函数的返回值）；&lt;/li&gt;
&lt;li&gt;引用计数递减：赋予新值、被销毁（如离开作用域）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;shared_ptr的析构函数使其具有管理动态内存的功能。它会递减shared_ptr所指向的对象的引用计数。如果引用计数变为0，就会销毁对象，并释放所占用的内存。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;auto r = make_shared&amp;lt;int&amp;gt;(4);   //r指向的int只有一个引用者
r = q;                          //给r赋值，则r原来指向的对象的引用计数递减
                                //r原来指向的对象已没有引用者，会自动释放
                                //q指向的对象的引用计数递增
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这样使用shared_ptr：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//factory返回一个shared_ptr，指向一个动态分配的对象
shared_ptr&amp;lt;Foo&amp;gt; factory(T arg) {
    ...
    return make_shared&amp;lt;Foo&amp;gt;(arg);
}

void use_factory(T arg) {
    shared_ptr&amp;lt;Foo&amp;gt; p = factory(arg);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于p是局部变量，在函数结束时将被销毁。在p被销毁时，其引用计数递减。在此由于p是唯一引用factory返回的内存的对象，所以引用计数将为0，则p所指的对象也会被销毁，所占用内存会被释放。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;void use_factory(T arg) {
    shared_ptr&amp;lt;Foo&amp;gt; p = factory(arg);
    return p;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里做了更改，return一个p的拷贝，这会递增其引用计数。当p被销毁时，由于它所指向的内存还有其他使用者，所以不会被释放。&lt;/p&gt;
&lt;p&gt;使用智能指针可以在多个对象间共享数据，即多个对象保存相同内容（存放在动态内存中）。这样，当一个对象被销毁时，不影响其他的对象；只有所有指向该内存的对象都被销毁时，该内存才会被释放。&lt;/p&gt;
&lt;h1 id="shared_ptr"&gt;四、shared_ptr的实现&lt;/h1&gt;</summary><category term="C++"></category></entry><entry><title>MySQL之数据操纵</title><link href="http://lhqqqqq.github.io/database/MySQL.html" rel="alternate"></link><updated>2015-04-16T18:28:37+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-16:database/MySQL.html</id><summary type="html">&lt;!--MySQL之数据操纵--&gt;
&lt;h1 id=""&gt;一、基本语法&lt;/h1&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;选择：select &amp;lt;fields&amp;gt; from &amp;lt;table&amp;gt; where &amp;lt;condition&amp;gt;;
插入：insert into &amp;lt;table&amp;gt;(&amp;lt;field1&amp;gt;,&amp;lt;field2&amp;gt;) values(&amp;lt;value1&amp;gt;,&amp;lt;value2&amp;gt;); 
删除：delete from &amp;lt;table&amp;gt; where &amp;lt;condition&amp;gt;; 
更新：update &amp;lt;table&amp;gt; set &amp;lt;field&amp;gt;=&amp;lt;value&amp;gt; where &amp;lt;condition&amp;gt;; 
查找：select &amp;lt;fields&amp;gt; from &amp;lt;table&amp;gt; where &amp;lt;field1&amp;gt; like '%&amp;lt;value&amp;gt;%' 
排序：select &amp;lt;fields&amp;gt; from &amp;lt;table&amp;gt; order by &amp;lt;field1&amp;gt;,&amp;lt;field2&amp;gt; [desc] [limit &amp;lt;number&amp;gt;];
总数：select count [as &amp;lt;columnname&amp;gt;] from table1; 
求和：select sum(&amp;lt;field&amp;gt;) from &amp;lt;table&amp;gt;; 
平均：select avg(&amp;lt;field&amp;gt;) from &amp;lt;table&amp;gt;; 
最大：select max(&amp;lt;field&amp;gt;) from &amp;lt;table&amp;gt;; 
最小：select min(&amp;lt;field&amp;gt;) from &amp;lt;table&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="join"&gt;二、join&lt;/h1&gt;
&lt;p&gt;举例说明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;Table1.
+----+-------+
| Id | book  |
+----+-------+
| 1  | java  |
| 2  | c++   |
| 3  | php   |
+----+-------+
Table2.
+----+-------+
| Id | author|
+----+-------+
| 2  | zhang |
| 2  | wang  |
| 3  | li    |
+----+-------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Iner Join(内连接)&lt;/strong&gt; 将两个表中存在连接关系的字段，组成的记录集。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mysql&amp;gt; select * from table1 join table2 on table1.id=table2.id;  
+------+------+------+--------+  
| id   | book | id   | author |  
+------+------+------+--------+  
|    2 | c++  |    2 | zhang  |  
|    3 | php  |    3 | wang   |  
+------+------+------+--------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用using子句&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mysql&amp;gt; select * from table1 inner join table2 using (id);  
+------+------+--------+  
| id   | book | author |  
+------+------+--------+  
|    2 | c++  | zhang  |  
|    3 | php  | wang   |  
+------+------+--------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mysql&amp;gt; select table1.id as id,book,author from table1, table2 where table1.id=table2.id; 
mysql&amp;gt; select table1.id, book, author from table1 join table2 on table1.id=table2.id;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Cross Join(交叉连接)&lt;/strong&gt; 求两个表的笛卡尔积，可以用逗号表示，如(table1, table 2)。不使用on或using时，和Inner Join是等价的。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mysql&amp;gt; select * from table1 inner join table2;  
mysql&amp;gt; select * from table1 cross join table2;  
mysql&amp;gt; select * from (table1, table2);   
+------+------+------+--------+  
| id   | book | id   | author |  
+------+------+------+--------+  
|    1 | java |    2 | zhang  |  
|    2 | c++  |    2 | zhang  |  
|    3 | php  |    2 | zhang  |  
|    1 | java |    3 | wang   |  
|    2 | c++  |    3 | wang   |  
|    3 | php  |    3 | wang   |  
|    1 | java |    4 | li     |  
|    2 | c++  |    4 | li     |  
|    3 | php  |    4 | li     |  
+------+------+------+--------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Natural Join 自然连接&lt;/strong&gt; 等价于使用using子句的Inner Join。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mysql&amp;gt; select * from table1 natural join table2;  
mysql&amp;gt; select * from table1 inner join table2 using (id);   
+------+------+--------+  
| id   | book | author |  
+------+------+--------+  
|    2 | c++  | zhang  |  
|    3 | php  | wang   |  
+------+------+--------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Left Join 左外连接&lt;/strong&gt; 左外连接A、B表的意思就是将表A中的全部记录和表B中字段连接形成的记录集，这里注意的是最后出来的记录集会包括表A的全部记录。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mysql&amp;gt; select * from table1 left join table2 on table1.id=table2.id; 
+------+------+------+--------+  
| id   | book | id   | author |  
+------+------+------+--------+
|    1 | java | NULL | NULL   |  
|    2 | c++  |    2 | zhang  |  
|    3 | php  |    3 | wang   |  
+------+------+------+--------+ 
mysql&amp;gt; select * from table2 right join table1 using (id);   
+------+------+--------+  
| id   | book | author |  
+------+------+--------+  
|    1 | java | NULL   |  
|    2 | c++  | zhang  |  
|    3 | php  | wang   |  
+------+------+--------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Right Join 右外连接&lt;/strong&gt; 右外连接和左外连接是类似的。为了方便数据库便于访问，推荐使用左外连接代替右外连接。&lt;/p&gt;
&lt;h1 id="inexists"&gt;三、in、exists&lt;/h1&gt;
&lt;p&gt;参考&lt;a href="http://sunxiaqw.blog.163.com/blog/static/990654382013430105130443/"&gt;http://sunxiaqw.blog.163.com/blog/static/990654382013430105130443/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt;查询相当于多个or条件的叠加&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where userId in (1, 2, 3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等效于&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where userId = 1 or userId = 2 or userId = 3;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;not in与in相反，如下&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where userId not in (1, 2, 3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等效于&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where userId != 1 and userId != 2 and userId != 3;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总的来说，in查询就是先将子查询条件的记录全都查出来，假设结果集为B，共有m条记录，然后在将子查询条件的结果集分解成m个，再进行m次查询。&lt;/p&gt;
&lt;p&gt;in查询的子条件返回结果必须只有一个字段，例如&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where userId in (select id from B);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不能是&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where userId in (select id, age from B);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;exists&lt;/strong&gt;对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where exists (select 1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对user表的记录逐条取出，由于子条件中的select 1永远能返回记录行，那么user表的所有记录都将被加入结果集，所以与 select * from user;是一样的&lt;/p&gt;
&lt;p&gt;又如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from user where exists (select * from user where userId = 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以知道对user表进行loop时，检查条件语句(select * from user where userId = 0),由于userId永远不为0，所以条件语句永远返回空集，条件永远为false，那么user表的所有记录都将被丢弃&lt;/p&gt;
&lt;p&gt;not exists与exists相反，也就是当exists条件有结果集返回时，loop到的记录将被丢弃，否则将loop到的记录加入结果集&lt;/p&gt;
&lt;p&gt;总的来说，如果A表有n条记录，那么exists查询就是将这n条记录逐条取出，然后判断n遍exists条件 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt;和&lt;strong&gt;exists&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;in是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。&lt;/p&gt;
&lt;p&gt;如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;若表A较小，表B较大&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from A where cc in(select cc from B)　　--&amp;gt;效率低，用到了A表上cc列的索引；
select * from A where exists(select cc from B where cc=A.cc)　　--&amp;gt;效率高，用到了B表上cc列的索引。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相反的：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select * from B where cc in(select cc from A)　　--&amp;gt;效率高，用到了B表上cc列的索引
select * from B where exists(select cc from A where cc=B.cc)　　--&amp;gt;效率低，用到了A表上cc列的索引。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;not in&lt;/strong&gt;和&lt;strong&gt;not exists&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;not in 逻辑上不完全等同于not exists&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;Table1.
+-----+-----+
| c1  | c2  |
+-----+-----+
| 1   | 2   |
| 1   | 3   |
+-----+-----+
Table2.
+-----+-----+
| c1  | c2  |
+-----+-----+
| 1   | 2   |
| 1   | null|
+-----+-----+
select * from Table1 where c2 not in(select c2 from Table2);　　--&amp;gt;执行结果：无
select * from Table1 where not exists(select 1 from Table2 where Table2.c2=Table1.c2)　　--&amp;gt;执行结果：1　　3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;not in出现了不期望的结果集，存在逻辑错误。尽量不要使用not in(它会调用子查询)，而尽量使用not exists（它会调用关联子查询）。如果子查询中返回的任意一条记录含有空值，则not in查询将不返回任何记录。如果子查询字段有非空限制，这时可以使用not in。&lt;/p&gt;
&lt;p&gt;如果查询语句使用了not in，那么对内外表都进行全表扫描，没有用到索引；而not exists的子查询依然能用到表上的索引。所以无论哪个表大，用not exists都比not in 要快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt;和&lt;strong&gt;=&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select name from student where name in('zhang','wang','zhao');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select name from student where name='zhang' or name='wang' or name='zhao'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的结果是相同的。&lt;/p&gt;
&lt;h1 id="group-by"&gt;四、group by&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;group by&lt;/strong&gt;语法可以根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。一般结合avg(),count()等进行统计。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;Table1.
+----+-------+
| Id | value |
+----+-------+
| 1  | 2     |
| 2  | 3     |
| 1  | 2     |
| 2  | 5     |
| 3  | 4     |
+----+-------+ 
select Id, avg(value) from Table1 group by Id;
+----+----------+
| Id |avg(value)|
+----+----------+
| 1  | 2        |
| 2  | 4        |
| 3  | 4        |
+----+----------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以使用&lt;strong&gt;having&lt;/strong&gt;子句测试一个统计结果，放在group by子句之后。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;select Id, avg(value) from Table1 group by Id having having count(*) &amp;gt; 1;
+----+----------+
| Id |avg(value)|
+----+----------+
| 1  | 2        |
| 2  | 4        |
+----+----------+
&lt;/pre&gt;&lt;/div&gt;</summary><category term="database"></category></entry><entry><title>算法之动态规划</title><link href="http://lhqqqqq.github.io/algorithm/dynamic.html" rel="alternate"></link><updated>2015-04-10T20:16:35+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-10:algorithm/dynamic.html</id><summary type="html">&lt;!--#算法之动态规划--&gt;
&lt;blockquote&gt;
&lt;p&gt;大篇幅参考&lt;a href="http://www.cnblogs.com/sdjl/articles/1274312.html"&gt;http://www.cnblogs.com/sdjl/articles/1274312.html&lt;/a&gt;，很好的故事 from &lt;a href="http://SDJL.me"&gt;SDJL&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=""&gt;一、什么是动态规划&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;在查找有很多&lt;em&gt;重叠子问题&lt;/em&gt;的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。&lt;/p&gt;
&lt;p&gt;动态规划只能应用于有&lt;em&gt;最优子结构的问题&lt;/em&gt;。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。&lt;/p&gt;
&lt;p&gt;from &lt;a href="http://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"&gt;wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;复杂的概念，根本看不懂，需要从问题引入。&lt;/p&gt;
&lt;p&gt;关于动态规划，最经典的是&lt;strong&gt;01背包问题&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？[对于每个物品不可以取多次，最多只能取一次，之所以叫做01背包，0表示不取，1表示取]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直观的去思考，每次选哪个互相牵制，思路很乱。&lt;/p&gt;
&lt;p&gt;为了用一种生动又更形象的方式来讲解此题，&lt;a href="http://SDJL.me"&gt;SDJL&lt;/a&gt;把此题用另一种方式来描述，直接复制过来了，如下：&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。&lt;/p&gt;
&lt;p&gt;题目补充1：挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为peopleNeeded[i]。&lt;/p&gt;
&lt;p&gt;题目补充2：每一座金矿所挖出来的金子数是固定的，当第i座金矿有peopleNeeded[i]人去挖的话，就一定能恰好挖出gold[i]个金子。否则一个金子都挖不出来。&lt;/p&gt;
&lt;p&gt;题目补充3：开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。&lt;/p&gt;
&lt;p&gt;题目补充4：国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。&lt;/p&gt;
&lt;p&gt;题目补充5：这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。&lt;/p&gt;
&lt;p&gt;题目补充6：有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。&lt;/p&gt;
&lt;p&gt;题目补充7：我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。&lt;/p&gt;
&lt;p&gt;那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？&lt;/p&gt;
&lt;p&gt;国王首先来到了第9个金矿的所在地（注意，第9个就是最后一个，因为是从0开始编号的，最西边的那个金矿是第0个），他的臣子告诉他，如果要挖取第9个金矿的话就需要1500个人，并且第9个金矿可以挖出8888个金子。听到这里国王哈哈大笑起来，因为原先他以为要知道十个金矿在仅有10000个人的情况下最多能挖出多少金子是一件很难思考的问题，但是，就在刚才听完他的臣子所说的那句话时，国王已经知道总共最多能挖出多少金子了，国王是如何在不了解其它金矿的情况下知道最多能挖出多少金子的呢？他的臣子们也不知道这个谜，因此他的臣子们就问他了：“最聪明的国王陛下，我们都没有告诉您其它金矿的情况，您是如何知道最终答案的呢？”&lt;/p&gt;
&lt;p&gt;得意的国王笑了笑，然后把他最得意的“左、右手”叫到跟前，说到：“我并不需要考虑最终要挖哪些金矿才能得到最多的金子，我只需要考虑我面前的这座金矿就可以了，对于我面前的这座金矿不外乎仅有两种选择，要么挖，要么不挖，对吧？”&lt;/p&gt;
&lt;p&gt;“当然，当然”大臣们回答到。&lt;/p&gt;
&lt;p&gt;国王继续说道：“如果我挖取第9座金矿的话那么我现在就能获得8888个金子，而我将用去1500个人，那么我还剩下8500个人。我亲爱的左部下，如果你告诉我当我把所有剩下的8500个人和所有剩下的其它金矿都交给你去开采你最多能给我挖出多少金子的话，那么我不就知道了在第9个金矿一定开采的情况下所能得到的最大金币数吗？”&lt;/p&gt;
&lt;p&gt;国王的左部下听后回答道：“国王陛下，您的意思是如果我能用8500个人在其它金矿最多开采出x个金币的话，那您一共就能够获得 x + 8888个金子，对吗？”&lt;/p&gt;
&lt;p&gt;“是啊，是啊……如果第9座金矿一定开采的话……”大臣们点头说到。&lt;/p&gt;
&lt;p&gt;国王笑着继续对着他的右部下说到：“亲爱的右部下，也许我并不打算开采这第9座金矿，那么我依然拥有10000个人，如果我把这10000个人和剩下的金矿都给你的话，你最多能给我挖出多少个金子呢？”&lt;/p&gt;
&lt;p&gt;国王的右部下聪明地说道：“尊敬的国王陛下，我明白您的意思了，如果我回答最多能购开采出y个金币的话，那您就可以在y和x+8888之间选择一个较大者，而这个较大者就是最终我们能获得的最大金币数，您看我这样理解对吗？”&lt;/p&gt;
&lt;p&gt;国王笑得更灿烂了，问他的左部下：“那么亲爱的左部下，我给你8500个人和其余金矿的话你能告诉我最多能挖出多少金子吗？”&lt;/p&gt;
&lt;p&gt;“请您放心，这个问题难不倒我”。左部下向国王打包票说到。&lt;/p&gt;
&lt;p&gt;国王高兴地继续问他的右部下：“那右部下你呢，如果我给你10000个人和其余金矿的话你能告诉我最多能挖出多少金子吗？”&lt;/p&gt;
&lt;p&gt;“当然能了！交给我吧！”右部下同左部下一样自信地回答道。&lt;/p&gt;
&lt;p&gt;“那就拜托给你们两位了，现在我要回到我那舒适的王宫里去享受了，我期待着你们的答复。”国王说完就开始动身回去等消息了，他是多么地相信他的两个大臣能够给他一个准确的答复，因为国王其实知道他的两位大臣要比他聪明得多。&lt;/p&gt;
&lt;p&gt;故事发展到这里，你是否在想国王的这两个大臣又是如何找到让国王满意的答案的呢？他们为什么能够如此自信呢？事实上他们的确比国王要聪明一些，因为他们从国王的身上学到了一点，就是这一点让他们充满了自信。&lt;/p&gt;
&lt;p&gt;国王走后，国王的左、右部下来到了第8座金矿，早已在那里等待他们的金矿勘测兵向两位大臣报道：“聪明的两位大臣，您们好，第8座金矿需要1000个人才能开采，可以获得7000个金子”。&lt;/p&gt;
&lt;p&gt;因为国王仅给他的左部下8500个人，所以国王的左部下叫来了两个人，对着其中一个人问到：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”&lt;/p&gt;
&lt;p&gt;然后国王的左部下继续问另一个人：“如果我给你8500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”&lt;/p&gt;
&lt;p&gt;国王的左部下在心里想着：“如果他们俩都能回答我的问题的话，那国王交给我的问题不就解决了吗？哈哈哈！”&lt;/p&gt;
&lt;p&gt;因为国王给了他的右部下10000个人，所以国王的右部下同样也叫来了两个人，对着其中一个人问：“如果我给你9000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”&lt;/p&gt;
&lt;p&gt;然后国王的右部下继续问他叫来的另一个人：“如果我给你10000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？”&lt;/p&gt;
&lt;p&gt;此时，国王的右部下同左部下一样，他们都在为自己如此聪明而感到满足。&lt;/p&gt;
&lt;p&gt;当然，这四个被叫来的人同样自信地回答没有问题，因为他们同样地从这两个大臣身上学到了相同的一点，而两位自认为自己一样很聪明的大臣得意地笑着回到了他们的府邸，等着别人回答他们提出来的问题，现在你知道了这两个大臣是如何解决国王交待给他们的问题了吗？&lt;/p&gt;
&lt;p&gt;那么你认为被大臣叫去的那四个人又是怎么完成大臣交给他们的问题的呢？答案当然是他们找到了另外八个人！&lt;/p&gt;
&lt;p&gt;没用多少功夫，这个问题已经在全国传开了，更多人的人找到了更更多的人来解决这个问题，而有些人却不需要去另外找两个人帮他，哪些人不需要别人的帮助就可以回答他们的问题呢？&lt;/p&gt;
&lt;p&gt;很明显，当被问到给你z个人和仅有第0座金矿时最多能挖出多少金子时，就不需要别人的帮助，因为你知道，如果z大于等于挖取第0座金矿所需要的人数的话，那么挖出来的最多金子数就是第0座金矿能够挖出来的金子数，如果这z个人不够开采第0座金矿，那么能挖出来的最多金子数就是0，因为这唯一的金矿不够人力去开采。让我们为这些不需要别人的帮助就可以准确地得出答案的人们鼓掌吧，这就是传说中的底层劳动人民！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;故事讲到这里先暂停一下，我们现在重新来分析一下这个故事，让我们对动态规划有个理性认识。&lt;/p&gt;
&lt;p&gt;子问题：&lt;/p&gt;
&lt;p&gt;国王需要根据两个大臣的答案以及第9座金矿的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外两个问题，这两个问题就是子问题。&lt;/p&gt;
&lt;p&gt;思考动态规划的第一点----最优子结构：&lt;/p&gt;
&lt;p&gt;国王相信，只要他的两个大臣能够回答出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），再加上他的聪明的判断就一定能得到最终的正确答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。&lt;/p&gt;
&lt;p&gt;思考动态规划的第二点----子问题重叠：&lt;/p&gt;
&lt;p&gt;实际上国王也好，大臣也好，所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出来的最多金子数。我们把这种母问题与子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。&lt;/p&gt;
&lt;p&gt;思考动态规划的第三点----边界：&lt;/p&gt;
&lt;p&gt;想想如果不存在前面我们提到的那些底层劳动者的话这个问题能解决吗？永远都不可能！我们把这种子问题在一定时候就不再需要提出子子问题的情况叫做边界，没有边界就会出现死循环。&lt;/p&gt;
&lt;p&gt;思考动态规划的第四点----子问题独立：&lt;/p&gt;
&lt;p&gt;要知道，当国王的两个大臣在思考他们自己的问题时他们是不会关心对方是如何计算怎样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。&lt;/p&gt;
&lt;p&gt;这就是动态规划，具有“最优子结构”、“子问题重叠”、“边界”和“子问题独立”，当你发现你正在思考的问题具备这四个性质的话，那么恭喜你，你基本上已经找到了动态规划的方法。&lt;/p&gt;
&lt;p&gt;有了上面的这几点，我们就可以写出动态规划的转移方程式，现在我们来写出对应这个问题的方程式，如果用gold[mineNum]表示第mineNum个金矿能够挖出的金子数，用peopleNeeded[mineNum]表示挖第mineNum个金矿需要的人数，用函数f(people,mineNum)表示当有people个人和编号为0、1、2、3、……、mineNum的金矿时能够得到的最大金子数的话，f(people,mineNum)等于什么呢？或者说f(people,mineNum)的转移方程是怎样的呢？&lt;/p&gt;
&lt;p&gt;答案是：&lt;/p&gt;
&lt;p&gt;当mineNum = 0且people &amp;gt;= peopleNeeded[mineNum]时 f(people,mineNum) = gold[mineNum]&lt;/p&gt;
&lt;p&gt;当mineNum = 0且people &amp;lt; peopleNeeded[mineNum]时 f(people,mineNum) = 0&lt;/p&gt;
&lt;p&gt;当mineNum != 0时 f(people,mineNum) = f(people-peopleNeeded[mineNum], mineNum-1) + gold[mineNum]与f(people, mineNum-1)中的较大者，前两个式子对应动态规划的“边界”，后一个式子对应动态规划的“最优子结构”请读者弄明白后再继续往下看。&lt;/p&gt;
&lt;h1 id="_1"&gt;二、为什么要用动态规划&lt;/h1&gt;
&lt;p&gt;现在我假设读者你已经搞清楚了为什么动态规划是正确的方法，但是我们为什么需要使用动态规划呢？请先继续欣赏这个故事：&lt;/p&gt;
&lt;p&gt;国王得知他的两个手下使用了和他相同的方法去解决交代给他们的问题后，不但没有认为他的两个大臣在偷懒，反而很高兴，因为他知道，他的大臣必然会找更多的人一起解决这个问题，而更多的人会找更更多的人，这样他这个聪明的方法就会在不经意间流传开来，而全国人民都会知道这个聪明的方法是他们伟大的国王想出来的，你说国王能不高兴吗？&lt;/p&gt;
&lt;p&gt;但是国王也有一些担忧，因为他实在不知道这个“工程”要动用到多少人来完成，如果帮助他解决这个问题的人太多的话那么就太劳民伤财了。“会不会影响到今年的收成呢？”国王在心里想着这个问题，于是他请来了整个国家里唯一的两个数学天才，一个叫做小天，另一个叫做小才。&lt;/p&gt;
&lt;p&gt;国王问小天：“小天啊，我发觉这个问题有点严重，我知道其实这可以简单的看成一个组合问题，也就是从十个金矿中选取若干个金矿进行开采，看看哪种组合得到的金子最多，也许用组合方法会更好一些。你能告诉我一共有多少种组合情况吗？”&lt;/p&gt;
&lt;p&gt;“国王陛下，如果用组合方法的话一共要考虑2的10次方种情况，也就是1024种情况。”小天思考了一会回答到。&lt;/p&gt;
&lt;p&gt;“嗯……，如果每一种情况我交给一个人去计算能得到的金子数的话，那我也要1024个人，其实还是挺多的。”国王好像再次感觉到了自己的方法是正确的。&lt;/p&gt;
&lt;p&gt;国王心理期待着小才能够给它一个更好的答案，问到：“小才啊，那么你能告诉我用我的那个方法总共需要多少人吗？其实，我也计算过，好像需要的人数是1+2+4+8+16+32+64+……，毕竟每一个人的确都需要找另外两个人来帮助他们……”&lt;/p&gt;
&lt;p&gt;不辜负国王的期待，小才微笑着说到：“亲爱的国王陛下，其实我们并不需要那么多人，因为有很多问题其实是相同的，而我们只需要为每一个不同的问题使用一个人力便可。”&lt;/p&gt;
&lt;p&gt;国王高兴的问到：“此话如何讲？”&lt;/p&gt;
&lt;p&gt;“打个比方，如果有一个人需要知道1000个人和3个金矿可以开采出多少金子，同时另一个人也需要知道1000个人和3个金矿可以开采出多少金子的话，那么他们可以去询问相同的一个人，而不用各自找不同的人浪费人力了。”&lt;/p&gt;
&lt;p&gt;国王思考着说到：“嗯，很有道理，如果问题是一样的话那么就不需要去询问两个不同的人了，也就是说一个不同的问题仅需要一个人力，那么一共有多少个不同的问题呢？”   &lt;/p&gt;
&lt;p&gt;“因为每个问题的人数可以从0取到10000，而金矿数可以从0取到10，所以最多大约有10000 * 10 等于100000个不同的问题。” 小才一边算着一边回答。&lt;/p&gt;
&lt;p&gt;“什么？十万个问题？十万个人力？”国王有点失望。&lt;/p&gt;
&lt;p&gt;“请国王放心，事实上我们需要的人力远远小于这个数的，因为不是每一个问题都会遇到，也许我们仅需要一、两百个人力就可以解决这个问题了，这主要和各个金矿所需要的人数有关。” 小才立刻回答到。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;   故事的最后，自然是国王再一次向他的臣民们证明了他是这个国家里最聪明的人，现在我们通过故事的第二部分来考虑动态规划的另外两个思考点。



   思考动态规划的第五点----做备忘录：

   正如上面所说的一样，当我们遇到相同的问题时，我们可以问同一个人。讲的通俗一点就是，我们可以把问题的解放在一个变量中，如果再次遇到这个问题就直接从变量中获得答案，因此每一个问题仅会计算一遍，如果不做备忘的话，动态规划就没有任何优势可言了。



   思考动态规划的第六点----时间分析：

   正如上面所说，如果我们用穷举的方法，至少需要2^n个常数时间，因为总共有2^n种情况需要考虑，如果在背包问题中，包的容量为1000，物品数为100，那么需要考虑2^100种情况,这个数大约为10的30次方。



   而如果用动态规划，最多大概只有1000*100 = 100000个不同的问题，这和10的30次方比起来优势是很明显的。而实际情况并不会出现那么多不同的问题，比如在金矿模型中，如果所有的金矿所需人口都是1000个人，那么问题总数大约只有100个。



   非正式地，我们可以很容易得到动态规划所需时间，如果共有questionCount个相同的子问题，而每一个问题需要面对chooseCount种选择时，我们所需时间就为questionCount * chooseCount个常数。在金矿模型中，子问题最多有大概people * n 个(其中people是用于开采金矿的总人数，n是金矿的总数)，因此questionCount = people * n，而就像国王需要考虑是采用左部下的结果还是采用右部下的结果一样，每个问题面对两个选择，因此chooseCount = 2,所以程序运行时间为 T = O(questionCount * chooseCount) =O(people * n)，别忘了实际上需要的时间小于这个值，根据所遇到的具体情况有所不同。



   这就是动态规划的魔力，它减少了大量的计算，因此我们需要动态规划！
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_1_2"&gt;三、实现&lt;/h1&gt;
&lt;h1 id="_1_2_3"&gt;四、递归&lt;/h1&gt;
&lt;h1 id="_1_2_3_4"&gt;五、非递归&lt;/h1&gt;</summary><category term="algorithm"></category></entry><entry><title>C++11新特性记录</title><link href="http://lhqqqqq.github.io/cpp/cpp11.html" rel="alternate"></link><updated>2015-04-08T09:23:50+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-08:cpp/cpp11.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;C++11&lt;/p&gt;
&lt;p&gt;C++11标准是 ISO/IEC 14882:2011 - Information technology -- Programming languages -- C++ 的简称。
C++11标准由国际标准化组织（ISO）和国际电工委员会（IEC）旗下的C++标准委员会（ISO/IEC JTC1/SC22/WG21）于2011年8月12日公布，并于2011年9月出版。2012年2月28日的国际标准草案(N3376)是最接近于C++11标准的草案（仅编辑上的修正）。此次标准为C++98发布后13年来第一次重大修正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;auto &amp;amp; decltype&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auto&lt;/strong&gt;：让编译器分析表达式所属的类型。auto定义的变量必须有初始值。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;auto i = 1, *p = &amp;amp;i; //整型，整型指针
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用在容器中&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;auto len = str.size(); //len的类型是string::size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用在容器的迭代器中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpp
vector&amp;lt;int&amp;gt; v{1, 2, 3};
for (auto it = v.begin(); it != v.end; ++i)
    (*it)++;
//it的类型为vector&amp;lt;int&amp;gt;::iterator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;decltype&lt;/strong&gt;：选择并返回操作数的数据类型。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;decltype(f()) sum = x;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译器不实际调用函数f，而是使用f返回值类型来作为sum的类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;decltype((variable))的结果永远是引用，decltype(variable)的结果只有当variable本身是引用时才是引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范围for语句&lt;/p&gt;
&lt;p&gt;遍历给定序列中的每个元素并对序列中的每个值执行某种操作&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for (declaration: expression)
    statement
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;expression部分是一个对象，用于表示一个序列；declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。
如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;string str("Hello world!");
for (auto c : str)
    cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表初始化&lt;/p&gt;
&lt;p&gt;列表初始化不再局限于数组。无论是初始化对象还是某些时候为新对象赋值，都可以使用一组花括号括起来的初始值。&lt;/p&gt;
&lt;p&gt;如，容器初始化&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;vector&amp;lt;int&amp;gt; v = {1, 2, 3};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;vector&amp;lt;int&amp;gt; v{1, 2, 3};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取代以前的方法：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int arr[3] = {1, 2, 3}  
vector&amp;lt;int&amp;gt; v(arr, arr + 3);
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="shared_ptr.html"&gt;智能指针&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无序关联容器
    关键字类型固有且无序，使用哈希函数和关键字类型的==运算符来组织元素。
    包括unordered_map，unordered_set，unordered_multimap，unordered_multiset。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;待续&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="C++"></category></entry><entry><title>C++中的引用</title><link href="http://lhqqqqq.github.io/cpp/reference.html" rel="alternate"></link><updated>2015-04-07T15:04:40+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-07:cpp/reference.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;from 《C++ Primer》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=""&gt;一、概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;引用（reference）&lt;/strong&gt;的符号为&amp;amp;，一般指“左值引用”，作用是为对象起一个别名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C++11引入了一种“右值引用”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义引用时，程序把初始值和对象绑定在一次。之后，这种绑定关系会一直存在，所以引用必须初始化。
引用本身不是对象。&lt;/p&gt;
&lt;h1 id="_1"&gt;二、示例&lt;/h1&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int ival = 1024;
int &amp;amp;refVal = ival; //引用，即refVal是ival的别名
int &amp;amp;refVal2; //报错，引用必须被初始化
int &amp;amp;refVal3 = 10; //报错，引用的初始值必须是对象
double dval = 3.14;
int &amp;amp;refVal4 = dval; //报错，类型不一致
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_1_2"&gt;三、有用的地方&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据交换，传递引用参数，可以改变原值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int swap(int &amp;amp;a, int &amp;amp;b)
{
    int tmp = a;
    a = b;
    b = tmp;    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数传递的参数必须为引用形式，否则会循环调用；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《C++ Primer》 P442&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传入参数为引用类型，可以避免从形参到实参的一次复制构造函数，减少无谓的消耗，提高代码效率&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《剑指offer》 P25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未完待续&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="_1_2_3"&gt;四、弱引用与强引用&lt;/h1&gt;
&lt;p&gt;C语言中有&lt;a href="http://blog.csdn.net/astrotycoon/article/details/8008629"&gt;强符号与弱符号&lt;/a&gt;的概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有用的命令:nm，列出指定文件的所有符号（包括静态和动态链接库）
&lt;a href="http://www.cnblogs.com/itech/archive/2012/09/16/2687423.html"&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="1"&gt;1.为什么有引用计数&lt;/h2&gt;
&lt;p&gt;C++中存在两种语义：值语义（value sematics）和对象语义（object sematic），对象语义也可以叫做引用语义（reference sematics）。&lt;/p&gt;
&lt;p&gt;值语义，指的是对象的拷贝与原对象无关，就像拷贝int一样，C++的常用类型数据等都是值语义。&lt;/p&gt;
&lt;p&gt;对象语义，指的是面向对象意义下的对象，是禁止拷贝的。
在设计一个类的时候该类是否可以被拷贝（即具备拷贝构造函数），取决于拷贝后的语义是否成立，比如一个Thread类，拷贝后系统中并不会启动另外一个线程，所以拷贝是禁止的。同样类似于Employee雇员类也是。
这么设计起码有两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语义合理，有些对象复制是不符合常理的&lt;/li&gt;
&lt;li&gt;节省内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在多线程程序中，一个对象如果被多个线程访问，一般使用shared_ptr，通过引用计数来保证对象不被错误的释放导致其他线程访问出现问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;shared_ptr：&lt;a href="shared_ptr.html" title="智能指针"&gt;智能指针&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="2"&gt;2.强引用&lt;/h2&gt;
&lt;p&gt;当对象被创建时，计数为1；每创建一个变量引用该对象时，该对象的计数就增加1；当上述变量销毁时，对象的计数减1，当计数为0时，这个对象也就被析构了。&lt;/p&gt;
&lt;p&gt;强引用：即当至少有一个强引用时，对象就不能被释放。shared_ptr就是如此。&lt;/p&gt;
&lt;p&gt;强引用计数在很多种情况下都是可以正常工作的，但是也有不凑效的时候，当出现循环引用时，就会出现严重的问题，以至于出现内存泄露。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;Class Parent  
{  
public:  
    // ...  
private:  
    shared_ptr&amp;lt;Child&amp;gt; m_child;  
}

Class Child  
{  
public:  
    // ...  
private:  
    shared_ptr&amp;lt;Parent&amp;gt; m_parent;  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于两个类之间互相引用，它们的计数都是1，最后谁也不会被释放，就导致了内存泄漏。&lt;/p&gt;
&lt;p&gt;一般解除循环引用有三种办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动释放&lt;/li&gt;
&lt;li&gt;如果Parent拥有Child，即Parent的生存期比Child大，那么Child就使用一个普通的指针&lt;/li&gt;
&lt;li&gt;使用弱引用的智能指针打破循环引用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。&lt;/p&gt;
&lt;h2 id="3"&gt;3.弱引用&lt;/h2&gt;
&lt;p&gt;弱引用：它仅仅是对象存在时候的引用，当对象不存在时弱引用能够检测到，从而避免非法访问，弱引用也不会修改对象的引用计数。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;template&amp;lt;typename T&amp;gt; class weak_ptr  
{  
    public:  
        template &amp;lt;typename Y&amp;gt;  
        weak_ptr(const shared_ptr&amp;lt;Y&amp;gt;&amp;amp; r);

        weak_ptr(const weak_ptr&amp;amp; r);

        ~weak_ptr();

        T* get() const;   
        bool expired() const;   
        shared_ptr&amp;lt;T&amp;gt; lock() const;  
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义变量：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;shared_ptr&amp;lt;T&amp;gt; t(new T);
weak_ptr&amp;lt;T&amp;gt; ptr(t); // t为一个T对象
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则当t被销毁时，ptr 被自动置为无效。使用方法如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;if ( shard_ptr&amp;lt;T&amp;gt; safePtr = ptr.lock() )  safePtr-&amp;gt;Fun();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;weak_ptr必须从一个share_ptr或另一个weak_ptr转换而来，这也说明，进行该对象的内存管理的是那个强引用的share_ptr。weak_ptr只是提供了对管理对象的一个访问手段。&lt;/p&gt;
&lt;p&gt;弱引用指针可以有效的解除循环引用，但这种方式必须在程序员能预见会出现循环引用的情况下才能使用，也可以是说这个仅仅是一种编译期的解决方案，如果程序在运行过程中出现了循环引用，还是会造成内存泄漏的。&lt;/p&gt;</summary><category term="C++"></category></entry><entry><title>数据结构之树</title><link href="http://lhqqqqq.github.io/data-structures/tree.html" rel="alternate"></link><updated>2015-04-04T17:30:00+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-04:data-structures/tree.html</id><summary type="html">&lt;!--#数据结构之树--&gt;
&lt;h1 id=""&gt;一、概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;树（tree）&lt;/strong&gt;：由n（n&amp;gt;=1）个有限节点组成一个具有层次关系的集合；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;度&lt;/strong&gt;：节点的子树个数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的度&lt;/strong&gt;：树中任意节点的度的最大值；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;兄弟&lt;/strong&gt;：两节点的父节点相同；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层&lt;/strong&gt;：根在第一层，以此类推；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度&lt;/strong&gt;：叶子节点的高度为1，根节点高度最高；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;：每个节点最多有两个子树的树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;满二叉树&lt;/strong&gt;：叶子节点一定要在最后一层，并且所有非叶子节点都存在左孩子和右孩子；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;：除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。&lt;/p&gt;
&lt;h1 id="_1"&gt;二、二叉树性质&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在非空二叉树中，第i层的结点总数不超过2&lt;sup&gt;i&lt;/sup&gt;-1, i&amp;gt;=1；&lt;/li&gt;
&lt;li&gt;深度为h的二叉树最多有2&lt;sup&gt;h&lt;/sup&gt;-1个结点(h&amp;gt;=1)，最少有h个结点；&lt;/li&gt;
&lt;li&gt;对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；&lt;/li&gt;
&lt;li&gt;具有n个结点的完全二叉树的深度为log&lt;sub&gt;2&lt;/sub&gt;(n+1)&lt;/li&gt;
&lt;li&gt;有N个结点的完全二叉树各结点如果用顺序方式存储，若I为结点编号，则结点之间有如下关系：&lt;ul&gt;
&lt;li&gt;如果I&amp;gt;1，则其父结点的编号为I/2；&lt;/li&gt;
&lt;li&gt;如果2*I&amp;lt;=N，则其左儿子（即左子树的根结点）的编号为2*I&lt;/li&gt;
&lt;li&gt;若2*I&amp;gt;N，则无左儿子；&lt;/li&gt;
&lt;li&gt;如果2*I+1&amp;lt;=N，则其右儿子的结点编号为2*I+1；若2*I+1&amp;gt;N，则无右儿子。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;给定N个节点，能构成h(N)种不同的二叉树。
h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。&lt;/li&gt;
&lt;li&gt;设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="_1_2"&gt;三、实现&lt;/h1&gt;
&lt;p&gt;树节点实现&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;struct TreeNode  
{  
    int val;  
    TreeNode *left;  
    TreeNode *right;  
    TreeNode(int val):val(val), left(NULL),right(NULL){} ;   
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前序遍历（PreorderTraversal），根-&amp;gt;左-&amp;gt;右&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;void PreorderTraversal(TreeNode *node)  
{  
    if(!node)  
        return; 
    Visit(T); 
    PreorderTraversal(node-&amp;gt;left);  
    PreorderTraversal(node-&amp;gt;right);  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中序遍历（InorderTraversal），左-&amp;gt;根-&amp;gt;右&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;void PreorderTraversal(TreeNode *node)  
{  
    if(!node)  
        return; 
    PreorderTraversal(node-&amp;gt;left);  
    Visit(T);       
    PreorderTraversal(node-&amp;gt;right);  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后序遍历（PostorderTraversal），左-&amp;gt;右-&amp;gt;根&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;void PreorderTraversal(TreeNode *node)  
{  
    if(!node)  
        return;
    PreorderTraversal(node-&amp;gt;left);  
    PreorderTraversal(node-&amp;gt;right); 
    Visit(T);   
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_1_2_3"&gt;四、递归&lt;/h1&gt;
&lt;p&gt;深度优先搜索(Depth-firsh Search)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int Foo1(TreeNode *root) {
    if (!root) //终止条件
        return ;
    if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) //剪枝
        return ;
    /*if (!root-&amp;gt;left) //剪枝
        return (root-&amp;gt;right);
    if (!root-&amp;gt;right) //剪枝
        return (root-&amp;gt;left);*/
    return ; //合并
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果父节点需要子节点的数据，只需要逐层返回；&lt;/p&gt;
&lt;p&gt;如果子节点需要父节点的数据，则需要在递归函数的参数中传递。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;int Foo2(TreeNode *root, int data)；
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_1_2_3_4"&gt;五、非递归&lt;/h1&gt;</summary><category term="data structures"></category></entry><entry><title>排序算法之快速排序</title><link href="http://lhqqqqq.github.io/algorithm/quicksort.html" rel="alternate"></link><updated>2015-04-07T15:08:23+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-04-01:algorithm/quicksort.html</id><summary type="html">&lt;!--排序算法之快速排序--&gt;
&lt;blockquote&gt;
&lt;p&gt;from 《数据结构与算法分析——c语言描述》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=""&gt;一、思路&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;快速排序（quicksort）&lt;/strong&gt;是实践中最快的已知排序算法。之所以快，是因为非常精炼和高度优化的内部循环。快速排序是一种分治的递归算法。&lt;/p&gt;
&lt;p&gt;将数组&lt;em&gt;S&lt;/em&gt;排序的基本算法由下列四步组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;em&gt;S&lt;/em&gt;中元素个数是1或0，则返回；&lt;/li&gt;
&lt;li&gt;取&lt;em&gt;S&lt;/em&gt;中任一元素&lt;em&gt;v&lt;/em&gt; ，称之为&lt;strong&gt;枢纽元（pivot）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;将&lt;em&gt;S - {v}&lt;/em&gt;（&lt;em&gt;S&lt;/em&gt;中其余元素）分成两个不想交的集合： &lt;em&gt;S&lt;sub&gt;1&lt;/sub&gt; = {x ∈ S - {v} | x≤v}&lt;/em&gt; 和 &lt;em&gt;S&lt;sub&gt;2&lt;/sub&gt; = {x ∈ S - {v} | x≥v}&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;返回{quicksort（&lt;em&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;）后，继随&lt;em&gt;v&lt;/em&gt;，继而quicksort（&lt;em&gt;S&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;）}。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图为一个示例，其中65为随机选取的枢纽元。
&lt;img alt="1" src="jpgs/quicksort.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;快排更快的原因，在于第3步分割成两组实际上是在适当的位置进行并且非常有效，它的高效弥补了大小不等的递归调用的缺憾而且还有超出。&lt;/p&gt;
&lt;h1 id="_1"&gt;二、细节&lt;/h1&gt;
&lt;h2 id="1"&gt;1. 选取枢纽元&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一种错误的方法&lt;/strong&gt;：选取第一个元素。如果输入是预排序或者是反序的，花费时间将是O(n&lt;sup&gt;2&lt;/sup&gt;)。另一种选取前两个互易的较大者作为枢纽元的想法，和选取第一个具有相同的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一种安全的做法&lt;/strong&gt;：随机选取。一方面随机数生成器可能有问题，另一方面随机数生成昂贵的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;三数中值分割法（Median-of-Three Partitioning）&lt;/strong&gt;：左端、右端和中心位置的三个元素的中值作为枢纽元。*使用三数中值分割法减少了快速排序大约5%的运行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2"&gt;2. 分割策略&lt;/h2&gt;
&lt;h1 id="_1_2"&gt;三、实现&lt;/h1&gt;</summary><category term="algorithm"></category></entry><entry><title>哲学家就餐问题</title><link href="http://lhqqqqq.github.io/os/philosophers.html" rel="alternate"></link><updated>2015-03-24T16:40:00+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-03-24:os/philosophers.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;经典的IPC问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1965年，Dijkstra提出并解决了一个他称之为哲学家就餐的同步问题。从那时起，每个发明新的同步原语的人都希望通过解决哲学家就餐问题来展示其同步原语的精妙之处。这个问题可以简单地描述如下：五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一盘通心粉。由于通心粉很滑，所以需要两把叉子才能夹住。相邻两个盘子之间放有一把叉子，餐桌如图2-44所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="http://images.51cto.com/files/uploadimg/20090805/120148542.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;哲学家的生活中有两种交替活动时段：即吃饭和思考（这只是一种抽象，即对哲学家而言其他活动都无关紧要）。当一个哲学家觉得饿了时，他就试图分两次去取其左边和右边的叉子，每次拿一把，但不分次序。如果成功地得到了两把叉子，就开始吃饭，吃完后放下叉子继续思考。关键问题是：能为每一个哲学家写一段描述其行为的程序，且决不会死锁吗？（要求拿两把叉子是人为规定的，我们也可以将意大利面条换成中国菜，用米饭代替通心粉，用筷子代替叉子。）&lt;/p&gt;
&lt;p&gt;图2-45给出了一种直观的解法。过程take_fork将一直等到所指定的叉子可用，然后将其取用。不过，这种显然的解法是错误的。如果五位哲学家同时拿起左面的叉子，就没有人能够拿到他们右面的叉子，于是发生死锁。&lt;/p&gt;
&lt;p&gt;我们可以将这个程序修改一下，这样在拿到左叉后，程序要查看右面的叉子是否可用。如果不可用，则该哲学家先放下左叉，等一段时间，再重复整个过程。但这种解法也是错误的，尽管与前一种原因不同。可能在某一个瞬间，所有的哲学家都同时开始这个算法，拿起其左叉，看到右叉不可用，又都放下左叉，等一会儿，又同时拿起左叉，如此这样永远重复下去。对于这种情况，所有的程序都在不停地运行，但都无法取得进展，就称为饥饿（starvation）。（即使问题不发生在意大利餐馆或中国餐馆，也被称为饥饿。）&lt;/p&gt;
&lt;p&gt;&lt;img alt="2" src="http://images.51cto.com/files/uploadimg/20090805/120227999.jpg"/&gt;&lt;br/&gt;
图2-45   哲学家就餐问题的一种错误解法&lt;/p&gt;
&lt;p&gt;现在读者可能会想，“如果哲学家在拿不到右边叉子时等待一段随机时间，而不是等待相同的时间，这样发生互锁的可能性就很小了，事情就可以继续了。”这种想法是对的，而且在几乎所有的应用程序中，稍后再试的办法并不会演化成为一个问题。例如，在流行的局域网以太网中，如果两台计算机同时发送包，那么每台计算机等待一段随机时间之后再尝试。在实践中，该方案工作良好。但是，在少数的应用中，人们希望有一种能够始终工作的方案，它不能因为一串不可靠的随机数字而导致失败（想象一下核电站中的安全控制系统）。&lt;/p&gt;
&lt;p&gt;对图2-45中的算法可做如下改进，它既不会发生死锁又不会产生饥饿：使用一个二元信号量对调用think之后的五个语句进行保护。在开始拿叉子之前，哲学家先对互斥量 mutex执行down操作。在放回叉子后，他再对mutex执行up操作。从理论上讲，这种解法是可行的。但从实际角度来看，这里有性能上的局限：在任何一时刻只能有一位哲学家进餐。而五把叉子实际上可以允许两位哲学家同时进餐。&lt;/p&gt;
&lt;p&gt;图2-46中的解法不仅没有死锁，而且对于任意位哲学家的情况都能获得最大的并行度。算法中使用一个数组state跟踪每一个哲学家是在进餐、思考还是饥饿状态（正在试图拿叉子）。一个哲学家只有在两个邻居都没有进餐时才允许进入到进餐状态。第 i个哲学家的邻居则由宏LEFT和RIGHT定义，换言之，若i为2，则LEFT为1，RIGHT为3。&lt;/p&gt;
&lt;p&gt;&lt;img alt="3" src="http://images.51cto.com/files/uploadimg/20090805/120310117.jpg"/&gt;
&lt;img alt="4" src="http://images.51cto.com/files/uploadimg/20090805/120410543.jpg"/&gt; &lt;br/&gt;
图2-46   哲学家就餐问题的一个解法&lt;/p&gt;
&lt;p&gt;该程序使用了一个信号量数组，每个信号量对应一位哲学家，这样在所需的叉子被占用时，想进餐的哲学家就被阻塞。注意，每个进程将过程philosopher作为主代码运行，而其他过程take_forks、put_forks和test只是普通的过程，而非单独的进程。&lt;/p&gt;
&lt;p&gt;[1]&lt;a href="http://baike.baidu.com/link?url=4YykWayXt5Wfaz2AMbSBrZ-KrWsdsrY0jnGZWmYi9QbFRgXR0aaNrkQ0TFjcK0o-1OdQambiwBzjOvW6YtBW1K"&gt;http://baike.baidu.com/link?url=4YykWayXt5Wfaz2AMbSBrZ-KrWsdsrY0jnGZWmYi9QbFRgXR0aaNrkQ0TFjcK0o-1OdQambiwBzjOvW6YtBW1K&lt;/a&gt;
[2]&lt;a href="http://book.51cto.com/art/200907/138168.htm"&gt;http://book.51cto.com/art/200907/138168.htm&lt;/a&gt;
[3]&lt;a href="http://blog.csdn.net/ikikray/article/details/4042922"&gt;http://blog.csdn.net/ikikray/article/details/4042922&lt;/a&gt;&lt;/p&gt;</summary><category term="OS"></category></entry><entry><title>Blog on GitHub Pages，using Pelican</title><link href="http://lhqqqqq.github.io/personal/start.html" rel="alternate"></link><updated>2015-03-21T21:09:00+08:00</updated><author><name>lhqqqqq</name></author><id>tag:lhqqqqq.github.io,2015-03-21:personal/start.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Python3&lt;/li&gt;
&lt;li&gt;Pelican&lt;/li&gt;
&lt;li&gt;Markdown&lt;/li&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;/ul&gt;</summary><category term="test"></category></entry></feed>